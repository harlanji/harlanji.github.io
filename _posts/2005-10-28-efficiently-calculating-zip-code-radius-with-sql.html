---
layout: post
title: Efficiently Calculating Zip Code Radius With SQL
date: 2005-10-28
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
I've been curious about how the popular website MySpace manages to pull off its "search by distance" functionality using such a huge set of data. Sofar I've thought of a few options:<br /><br /><span style="font-weight: bold;">1) Do calculations with every query:</span><br /><pre>SELECT u.username,<br />SQRT((POW((69.1*(zd.lon-zd2.lon)*COS(zd2.lat/57.3)),2)+POW((69.1*(zd.lat-zd2.lat)),2))) AS distance<br />FROM zipdata zd, zipdata zd2<br />RIGHT JOIN users u ON u.zipcode = zd2.zipcode<br />WHERE zd.zipcode = 55431<br />AND (POW((69.1*(zd.lon-zd2.lon)*COS(zd2.lat/57.3)),2)+POW((69.1*(zd.lat-zd2.lat)),2)) &gt; 10</pre><br />Surprisingly, that is a very fast query. 30ms including transit.<br /><br /><span style="font-weight: bold;">2) Create a table with pre-calculated values selected into it. </span><span style="font-weight: bold;"><br />a.</span> see if the desired zipcode has been selected into the zipdistance table. If not, run the same query as above, only remove the distance limitation and insert it into zipdistance:<br /><pre>INSERT INTO zipdistance<br />SELECT zd.zipcode,<br />zd2.zipcode,<br />SQRT((POW((69.1*(zd.lon-zd2.lon)*COS(zd2.lat/57.3)),2)+POW((69.1*(zd.lat-zd2.lat)),2))) AS distance<br />FROM zipdata zd, zipdata zd2<br />WHERE zd.zipcode = 55431;</pre><span style="font-weight: bold;">b.</span> use zipdistance for the cross reference:<br /><pre>SELECT u.username, zd.distance FROM zipdistance zd<br />RIGHT JOIN users u ON zd.zip2 = u.zipcode<br />WHERE zd.zip1 = 55431<br />AND zd.distance &gt; 10;</pre>This method also requires 30ms including transit.<br /><br /><span style="font-weight: bold;">Conclusion</span><br />While one would think that solution 1 would be unbearably slow, it is actually quite fast when a JOIN operation is performed. My guess is that the optimizer only compares records that it finds in user zipcodes. So really since my dataset is small each solution is the same speed, but as the set of user data grows the database will have to compare more records and thus be slower to calculate (sol 1) than to lookup values in zipdistance (sol 2).<br /><br />One final thing to keep in mind: if you're using PostgreSQL, remember to VACUUM your tables!<br /><br /><span style="font-weight: bold;">Sources<br /></span><a href="http://www.sanisoft.com/ziploc/">http://www.sanisoft.com/ziploc/</a> - zipcode latitude and longitude data and some sample code for getting all zipcodes within radius<br /><br />Table structure for zipdistance:<br /><pre>CREATE TABLE zipdistance<br />(<br />zip1 int4 NOT NULL,<br />zip2 int4 NOT NULL,<br />distance float8 NOT NULL<br />)</pre></div>
